[{"/app/src/index.tsx":"1","/app/src/App.tsx":"2","/app/src/pages/MainPage/index.tsx":"3","/app/src/pages/DownloadPage/index.tsx":"4","/app/src/pages/ResizePage/index.tsx":"5","/app/src/pages/FirstPage/index.tsx":"6","/app/src/effector/event.ts":"7","/app/src/effector/store.ts":"8","/app/src/effector/stores/images.ts":"9","/app/src/effector/stores/kitsImagesSetting.ts":"10","/app/src/effector/stores/idxKitImages.ts":"11","/app/src/services/base64Service.ts":"12","/app/src/effector/stores/kitsImages.ts":"13","/app/src/effector/effect.ts":"14","/app/src/services/localStorageService.ts":"15","/app/src/effector/stores/stateCropPoint.ts":"16","/app/src/utils/differentFunc.ts":"17","/app/src/components/CustomModal/index.tsx":"18","/app/src/components/Crop/index.tsx":"19","/app/src/components/Gallery/index.tsx":"20","/app/src/components/DownloadBtn/index.tsx":"21","/app/src/components/SettingsImg/index.tsx":"22","/app/src/components/BlockImgPreview/index.tsx":"23","/app/src/components/Dropzone/index.tsx":"24","/app/src/components/Buttons/controlStepperButtons/index.tsx":"25","/app/src/services/imageService.ts":"26","/app/src/services/fileService.ts":"27","/app/src/components/Crop/CropForm/index.tsx":"28","/app/src/components/Buttons/CloseButton/index.tsx":"29","/app/src/components/Dropzone/DropzonePreview/index.tsx":"30","/app/src/components/Thumb/index.tsx":"31"},{"size":167,"mtime":1639652242180,"results":"32","hashOfConfig":"33"},{"size":366,"mtime":1639652242162,"results":"34","hashOfConfig":"33"},{"size":2547,"mtime":1639652242184,"results":"35","hashOfConfig":"33"},{"size":419,"mtime":1639652242182,"results":"36","hashOfConfig":"33"},{"size":3848,"mtime":1639652242185,"results":"37","hashOfConfig":"33"},{"size":908,"mtime":1634310227069,"results":"38","hashOfConfig":"33"},{"size":1736,"mtime":1639652242175,"results":"39","hashOfConfig":"33"},{"size":3092,"mtime":1639652599155,"results":"40","hashOfConfig":"33"},{"size":668,"mtime":1640375717389,"results":"41","hashOfConfig":"33"},{"size":2329,"mtime":1639652242178,"results":"42","hashOfConfig":"33"},{"size":519,"mtime":1634310227065,"results":"43","hashOfConfig":"33"},{"size":1744,"mtime":1639652242186,"results":"44","hashOfConfig":"33"},{"size":2967,"mtime":1639652242177,"results":"45","hashOfConfig":"33"},{"size":2265,"mtime":1639652242174,"results":"46","hashOfConfig":"33"},{"size":682,"mtime":1634310227073,"results":"47","hashOfConfig":"33"},{"size":276,"mtime":1639652242179,"results":"48","hashOfConfig":"33"},{"size":1008,"mtime":1634310227074,"results":"49","hashOfConfig":"33"},{"size":647,"mtime":1639652242168,"results":"50","hashOfConfig":"33"},{"size":4552,"mtime":1639652242166,"results":"51","hashOfConfig":"33"},{"size":2370,"mtime":1639652242171,"results":"52","hashOfConfig":"33"},{"size":912,"mtime":1634310227059,"results":"53","hashOfConfig":"33"},{"size":2145,"mtime":1639652242172,"results":"54","hashOfConfig":"33"},{"size":4832,"mtime":1639652242163,"results":"55","hashOfConfig":"33"},{"size":1058,"mtime":1639652242170,"results":"56","hashOfConfig":"33"},{"size":837,"mtime":1639652242164,"results":"57","hashOfConfig":"33"},{"size":9393,"mtime":1639652242187,"results":"58","hashOfConfig":"33"},{"size":1049,"mtime":1634310227072,"results":"59","hashOfConfig":"33"},{"size":2059,"mtime":1639652242165,"results":"60","hashOfConfig":"33"},{"size":650,"mtime":1634310227055,"results":"61","hashOfConfig":"33"},{"size":875,"mtime":1639652242169,"results":"62","hashOfConfig":"33"},{"size":362,"mtime":1639652242173,"results":"63","hashOfConfig":"33"},{"filePath":"64","messages":"65","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"u4jpw6",{"filePath":"66","messages":"67","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"68","messages":"69","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"70","messages":"71","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"72","messages":"73","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"74","messages":"75","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"76","messages":"77","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"78","messages":"79","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"80","messages":"81","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"82","messages":"83","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"84"},{"filePath":"85","messages":"86","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"87","messages":"88","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"89","messages":"90","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"91"},{"filePath":"92","messages":"93","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"94"},{"filePath":"95","messages":"96","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"97"},{"filePath":"98","messages":"99","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"100","messages":"101","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"102"},{"filePath":"103","messages":"104","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"105","messages":"106","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"107"},{"filePath":"108","messages":"109","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"110","messages":"111","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"112","messages":"113","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"114","messages":"115","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"116"},{"filePath":"117","messages":"118","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"119","messages":"120","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"121","messages":"122","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"123"},{"filePath":"124","messages":"125","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"126","messages":"127","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"128"},{"filePath":"129","messages":"130","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"131","messages":"132","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"133","messages":"134","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/app/src/index.tsx",[],"/app/src/App.tsx",[],"/app/src/pages/MainPage/index.tsx",[],"/app/src/pages/DownloadPage/index.tsx",[],"/app/src/pages/ResizePage/index.tsx",[],"/app/src/pages/FirstPage/index.tsx",[],"/app/src/effector/event.ts",[],"/app/src/effector/store.ts",[],"/app/src/effector/stores/images.ts",[],"/app/src/effector/stores/kitsImagesSetting.ts",["135","136","137","138"],"import { calcPercentFromPx } from 'services/imageService';\nimport { createStore, forward, sample } from 'effector';\nimport * as events from '../event';\nimport * as effects from '../effect';\nimport { copyObject, deleteItemFromArrByIdx, setLengthKitsImagesFunc } from '../../utils/differentFunc';\nimport { saveDataInLocalStorage } from '../../services/localStorageService';\n\nconst initialStatePoint = {\n  pointWidth: null,\n  pointPlace: {\n    x: null,\n    y: null,\n  },\n};\n\nexport const $kitsImagesSetting = createStore<any>([])\n  .on(effects.getNewSettingsForKitImages.doneData, (state, { transformedSettings, idx }) => {\n    const newState = [...state];\n    newState.splice(idx, 1, transformedSettings);\n\n    return newState;\n  })\n  .on(events.addKitImageSettings, (state, { settingImg, idx, dataByNaturalSize }) => {\n    const newState = [...state];\n\n    const { naturalWidth, naturalHeight } = dataByNaturalSize;\n    const percentData = {\n      x: calcPercentFromPx(naturalWidth, settingImg.x),\n      y: calcPercentFromPx(naturalHeight, settingImg.y),\n      width: calcPercentFromPx(naturalWidth, settingImg.width),\n      height: calcPercentFromPx(naturalHeight, settingImg.height),\n    };\n\n    newState[idx].items.push(percentData);\n    return newState;\n  })\n  .on(events.cancelImg, deleteItemFromArrByIdx)\n  .on(events.setPointImgInKitImages, (state, { pointOnImg, idx }) => {\n    const newState = [...state];\n    const objSettings = newState[idx];\n\n    if (pointOnImg) {\n      objSettings.point = { ...pointOnImg };\n    } else {\n      objSettings.point = copyObject(initialStatePoint);\n    }\n\n    return newState;\n  })\n  .on(events.setCancelCropImg, (state, { idx, idxImg }) => {\n    const newState = [...state];\n    const objSettings = newState[idx];\n    objSettings.items.splice(idxImg, 1);\n\n    return newState;\n  })\n  .on(effects.fetchSettingsForImagesFx.doneData, (state, dataFromLocalStorage) => {\n    console.log('dataFromLocalStorage', dataFromLocalStorage);\n    return dataFromLocalStorage;\n  })\n  .on(events.setLengthKitsImages, (state, length) =>\n    setLengthKitsImagesFunc(state, length, {\n      point: initialStatePoint,\n      items: [],\n    })\n  );\n\n$kitsImagesSetting.watch((state) => {\n  console.log('want to save settingForKitsImages', state);\n\n  saveDataInLocalStorage('settingForKitsImages', state);\n});\n","/app/src/effector/stores/idxKitImages.ts",[],"/app/src/services/base64Service.ts",[],"/app/src/effector/stores/kitsImages.ts",["139","140"],"import { createStore, sample, guard, combine, restore, forward } from 'effector';\nimport * as events from '../event';\nimport * as effects from '../effect';\nimport { deleteItemFromArrByIdx, setLengthKitsImagesFunc } from '../../utils/differentFunc';\nimport { IInfoImg, IPointOnImg } from '../../interfaces/items';\nimport { $idxKitImages } from './idxKitImages';\nimport { $images } from './images';\nimport { $kitsImagesSetting } from './kitsImagesSetting';\nimport { $stateCropPoint } from './stateCropPoint';\n\nexport const $kitsImages = createStore<IInfoImg[][]>([])\n  .on(events.setLengthKitsImages, (state, length) => setLengthKitsImagesFunc(state, length, []))\n  .on(events.cancelImg, deleteItemFromArrByIdx)\n  .on([events.setKitImages, effects.generateKitImagesBySettings.doneData], (state, { kitImages, idx }) => {\n    if (kitImages.length === 0) {\n      return state;\n    }\n    const newState = [...state];\n    newState.splice(idx, 1, kitImages);\n    return newState;\n  })\n  .on(events.setCancelCropImg, (state, { idx, idxImg }) => {\n    const newState = [...state];\n    const kitImages = newState[idx];\n    kitImages.splice(idxImg, 1);\n\n    return newState;\n  })\n  .on(effects.generateKitsImages.doneData, (state, kitsImages) => {\n    let newState = [...state];\n    newState = newState.map((el, idx) => {\n      if (kitsImages[idx]) {\n        return kitsImages[idx];\n      }\n      return el;\n    });\n    return newState;\n  });\n\nguard({\n  source: combine([restore(effects.fetchImagesFx, []), restore(effects.fetchSettingsForImagesFx, [])]),\n  filter: (storeComb: any): any => storeComb[0].length && storeComb[1].length,\n  target: effects.generateKitsImages,\n});\n\nconst elementsForGenerateSettingsByPoint = sample(\n  combine([$idxKitImages, $images, $kitsImagesSetting]),\n  events.setPointImg,\n  (arrayStores: any, pointOnImg: IPointOnImg) => {\n    const { idx } = arrayStores[0];\n\n    return {\n      idx,\n      fileImage: arrayStores[1][idx],\n      kitImagesSetting: arrayStores[2][idx],\n      pointOnImg,\n    };\n  }\n);\n\nguard({\n  source: elementsForGenerateSettingsByPoint,\n  filter: ({ pointOnImg }) => pointOnImg !== null,\n  target: effects.getNewSettingsForKitImages,\n});\n\nconst elementsForGenerateKitImagesBySettings = sample(\n  combine([$idxKitImages, $images, $kitsImagesSetting, $stateCropPoint]),\n  $kitsImagesSetting,\n  (arrayStores: any) => {\n    const { idx } = arrayStores[0];\n    console.log(arrayStores);\n    return {\n      idx,\n      fileImage: arrayStores[1][idx],\n      kitImagesSetting: arrayStores[2][idx],\n      stateCropPoint: arrayStores[3],\n    };\n  }\n);\n\nguard({\n  source: elementsForGenerateKitImagesBySettings,\n  filter: ({ kitImagesSetting, stateCropPoint }) => kitImagesSetting?.point?.pointWidth !== null && stateCropPoint,\n  target: effects.generateKitImagesBySettings,\n});\n\n$kitsImages.watch((state) => {\n  const hasImages = state.some((kit: any) => kit.length);\n  if (hasImages) {\n    events.setIsCroppedImages(hasImages);\n  }\n});\n","/app/src/effector/effect.ts",["141"],"import { createEffect } from 'effector';\nimport { convertBase64ItemsInFiles } from '../services/base64Service';\nimport {\n  getImgFromPreviewFile,\n  generateKitImages,\n  generateNewSettingsForKitImages,\n  transformSettingsInPx,\n  transformSettingsInPercent,\n} from '../services/imageService';\nimport { IInfoImg, ISettingsImage } from '../interfaces/items';\n\nexport const fetchImagesFx = createEffect(async (data: any) => {\n  const req = await convertBase64ItemsInFiles(data);\n  return req;\n});\n\nexport const fetchSettingsForImagesFx = createEffect((data: any) => data);\n\nexport const generateKitsImages = createEffect(async (data: any): Promise<IInfoImg[][]> => {\n  const [images, settingsForKits] = data;\n  const kitsImages = [];\n  for (let idx = 0; idx < settingsForKits.length; idx++) {\n    const imageKitsettings = settingsForKits[idx];\n    const currentImg = images[idx];\n    const kitImages = await handleGenerateKitItemsBySettings(currentImg, imageKitsettings);\n    kitsImages.push(kitImages);\n  }\n\n  return kitsImages;\n});\n\nexport const getNewSettingsForKitImages = createEffect(\n  async (data: any): Promise<{ transformedSettings: ISettingsImage; idx: number }> => {\n    const { fileImage, kitImagesSetting, pointOnImg, idx } = data;\n\n    const imgElement = await getImgFromPreviewFile(fileImage.preview);\n    const newSettingsForKitImages = generateNewSettingsForKitImages(imgElement, kitImagesSetting.items, pointOnImg);\n    const transformedSettings = transformSettingsInPercent(newSettingsForKitImages, imgElement);\n    return { transformedSettings, idx };\n  }\n);\n\nexport const generateKitImagesBySettings = createEffect(\n  async (data: any): Promise<{ kitImages: IInfoImg[]; idx: number }> => {\n    const { fileImage, kitImagesSetting, idx } = data;\n    const kitImages = await handleGenerateKitItemsBySettings(fileImage, kitImagesSetting);\n\n    return { kitImages, idx };\n  }\n);\n\nconst handleGenerateKitItemsBySettings = async (\n  fileImage: IInfoImg,\n  kitImagesSetting: ISettingsImage\n): Promise<IInfoImg[]> => {\n  const imgElement = await getImgFromPreviewFile(fileImage.preview!);\n  const pxSettings = transformSettingsInPx(kitImagesSetting, imgElement);\n  const kitImages = await generateKitImages(imgElement, pxSettings);\n  return kitImages;\n};\n","/app/src/services/localStorageService.ts",["142"],"import { PossibleStringType } from '../interfaces/items';\nimport { convertFilesInBase64Items } from './base64Service';\n\nconst saveData = (localName: string, data: any) => {\n  const convertedDataToString = JSON.stringify(data);\n  localStorage.setItem(localName, convertedDataToString);\n};\n\nexport const saveDataInLocalStorage = (localName: string, data: any, type = 'string'): void => {\n  if (type === 'files') {\n    const convertedDataToBase64 = convertFilesInBase64Items(data);\n    convertedDataToBase64.then((results: PossibleStringType[]) => {\n      // console.log('results', results);\n      saveData(localName, results);\n    });\n  } else {\n    saveData(localName, data);\n  }\n};\n","/app/src/effector/stores/stateCropPoint.ts",[],"/app/src/utils/differentFunc.ts",["143","144"],"import { IPointPlace, IobjIdxKitImages } from '../interfaces/items';\n\nexport const findNewCurrentIdx = (state: IobjIdxKitImages, operation: string): IobjIdxKitImages => {\n  const newIdx = operation === '-' ? state.idx - 1 : state.idx + 1;\n\n  const hasIdx = newIdx <= state.maxIdx && newIdx > -1;\n  if (!hasIdx) {\n    return state;\n  }\n\n  return {\n    ...state,\n    idx: newIdx,\n  };\n};\n\nexport const deleteItemFromArrByIdx = <T>(state: Array<T>, idx: number): Array<T> => {\n  const newState = [...state];\n  newState.splice(idx, 1);\n  return newState;\n};\n\nexport const copyObject = <T>(object: T): T => JSON.parse(JSON.stringify(object));\n\nexport const setLengthKitsImagesFunc = <T>(state: Array<T>, length: number, newItem: T): Array<T> => {\n  const newState = [...state];\n  if (length > state.length) {\n    const needIncreaseLength = length - state.length;\n    const newItems = new Array(needIncreaseLength).fill(0).map(() => copyObject(newItem));\n\n    newState.push(...newItems);\n  }\n  return newState;\n};\n","/app/src/components/CustomModal/index.tsx",[],"/app/src/components/Crop/index.tsx",["145","146","147","148","149"],"/* eslint-disable jsx-a11y/no-static-element-interactions */\nimport React, { FC, useEffect, useRef, useState } from 'react';\nimport Cropper from 'react-cropper';\nimport 'cropperjs/dist/cropper.css';\n\nimport { useStore } from 'effector-react';\nimport { setCropDataPx, setAspect, setCropperRef, setTypeCrop } from 'effector/event';\nimport { ICropNewData, IImgSettingsNaturalSize, IPointOnImg, ISettingImg } from 'interfaces/items';\nimport CropForm from './CropForm';\nimport { $aspect, $cropDataPercent, $cropDataPx, $typeCrop } from '../../effector/store';\nimport { getPositionByPoint, calcPxFromPercent, transformPxAndPercent } from '../../services/imageService';\n\nconst Crop: FC<{\n  src: string;\n  point: IPointOnImg;\n  addCropedImg: (base64Img: string, settingImg: ISettingImg, dataByNaturalSize: IImgSettingsNaturalSize) => void;\n  onCloseModal: () => void;\n}> = ({ addCropedImg, src, onCloseModal, point }) => {\n  const typeCrop = useStore($typeCrop);\n  const cropperRef = useRef<HTMLImageElement>(null);\n  const cropDataPx = useStore($cropDataPx);\n  const cropDataPercent = useStore($cropDataPercent);\n  const aspect = useStore($aspect);\n\n  const [savedPxData, setSavedPxData] = useState(cropDataPx);\n  let changeActive = false;\n  const getCropper = () => {\n    const imageElement: any = cropperRef?.current;\n    const cropper: any = imageElement?.cropper;\n    return cropper;\n  };\n\n  useEffect(() => {\n    setCropperRef(cropperRef);\n  }, [cropperRef]);\n\n  const onCrop = () => {\n    if (changeActive) {\n      changeActive = false;\n      return;\n    }\n    const cropper: any = getCropper();\n    let newData = cropper.getData({ rounded: true });\n    const imgSettings = cropper.getImageData();\n\n    if (point.pointWidth) {\n      newData = getPositionByPoint(newData, point, imgSettings);\n    }\n    changeActive = true;\n\n    cropper.setData(newData);\n    setCropDataPx(newData);\n  };\n\n  const onSetCrop = (newValue: ICropNewData) => {\n    const cropper: any = getCropper();\n    const currenValues = cropper.getData({ rounded: true });\n    const imgSettings = cropper.getImageData();\n\n    let newValuesCrop = null;\n    let valueByPoint = null;\n\n    if (typeCrop === '%') {\n      const transformNewValue = transformPxAndPercent(cropperRef.current!, newValue, calcPxFromPercent);\n      newValuesCrop = { ...currenValues, ...transformNewValue };\n    } else {\n      newValuesCrop = { ...currenValues, ...newValue };\n    }\n\n    if (point.pointWidth) {\n      valueByPoint = getPositionByPoint(newValuesCrop, point, imgSettings);\n    }\n\n    cropper.setData(valueByPoint || newValuesCrop);\n  };\n\n  const transformDataByPointCrop = () => {\n    if (point) {\n      const cropper: any = getCropper();\n      const imgSettings = cropper.getImageData();\n      const cropperData = cropper.getData({ rounded: true });\n      const getData = getPositionByPoint(cropperData, point, imgSettings);\n\n      cropper.crop();\n      cropper.setData({ ...getData });\n    }\n  };\n\n  const getCropImage = () => {\n    const cropper: any = getCropper();\n    const cropperData = cropper.getData({ rounded: true });\n    const imgSettings = cropper.getImageData();\n\n    const dataByImg = {\n      x: cropperData.x,\n      y: cropperData.y,\n      width: cropperData.width,\n      height: cropperData.height,\n    };\n\n    const base64Img = cropper.getCroppedCanvas().toDataURL();\n\n    addCropedImg(base64Img, dataByImg, imgSettings);\n    onCloseModal();\n  };\n\n  useEffect(() => {\n    const cropper: any = getCropper();\n    if (typeCrop === 'aspect') {\n      cropper.setAspectRatio(aspect.value);\n    }\n  }, [aspect, typeCrop]);\n\n  useEffect(() => {\n    setTypeCrop('px');\n  }, []);\n\n  const onTypeCrop = (newType: string): void => {\n    if (typeCrop === 'aspect' && newType !== 'aspect') {\n      const cropper: any = getCropper();\n      cropper.setAspectRatio(NaN).setData({ ...cropDataPx });\n    }\n\n    setTypeCrop(newType);\n  };\n\n  return (\n    <>\n      <Cropper\n        ref={cropperRef}\n        autoCrop={false}\n        autoCropArea={1}\n        background={false}\n        crop={onCrop}\n        guides={false}\n        ready={() => {\n          transformDataByPointCrop();\n        }}\n        src={src}\n        viewMode={1}\n        zoomable={false}\n        responsive\n      />\n      <CropForm\n        aspect={aspect.sides}\n        cropPercent={cropDataPercent}\n        cropPx={cropDataPx}\n        getCropImage={getCropImage}\n        setTypeCrop={onTypeCrop}\n        typeCrop={typeCrop}\n        onSetAspect={setAspect}\n        onSetCrop={onSetCrop}\n      />\n    </>\n  );\n};\n\nexport default Crop;\n","/app/src/components/Gallery/index.tsx",[],"/app/src/components/DownloadBtn/index.tsx",[],"/app/src/components/SettingsImg/index.tsx",[],"/app/src/components/BlockImgPreview/index.tsx",["150","151","152","153"],"import React from 'react';\nimport { useStore } from 'effector-react';\nimport { $stateCropPoint } from 'effector/stores/stateCropPoint';\nimport styles from './BlockImgPreview.module.css';\nimport { calcPercentFromPx, calcPxStatePoint, calcWidthPoint } from '../../services/imageService';\nimport { IInfoImg, IPointOnImg, IPointPlace } from '../../interfaces/items';\nimport { setActiveChangeSettings } from '../../effector/event';\n\nconst getOffset = (e: React.MouseEvent<HTMLCanvasElement>): number[] => {\n  const x = e.nativeEvent.offsetX;\n  const y = e.nativeEvent.offsetY;\n  return [x, y];\n};\n\nconst BlockImgPreview: React.FC<{\n  statePoint: IPointOnImg;\n  currentImg: IInfoImg;\n  setStatePoint: (pxStatePoint?: any, newDataForPointWidth?: IPointPlace, canvas?: any) => void;\n}> = ({ currentImg, statePoint, setStatePoint }) => {\n  const canvasPreview: any = React.useRef(null);\n  const ImgPreview: any = React.useRef(null);\n\n  const [activeChange, setActiveChange] = React.useState<boolean>(false);\n  const [mouseIntoBlock, setMouseIntoBlock] = React.useState<boolean>(false);\n  const [pxStatePoint, setPxStatePoint] = React.useState<IPointOnImg>(\n    calcPxStatePoint(statePoint, canvasPreview.current)\n  );\n\n  const stateCropPoint = useStore($stateCropPoint);\n\n  const resize = React.useCallback(() => {\n    const canvas = canvasPreview.current;\n\n    const cs = getComputedStyle(ImgPreview.current);\n    const width = parseInt(cs.getPropertyValue('width'), 10);\n    const height = parseInt(cs.getPropertyValue('height'), 10);\n    canvas.width = width;\n    canvas.height = height;\n\n    setPxStatePoint(calcPxStatePoint(statePoint, canvasPreview.current));\n  }, [statePoint]);\n\n  const draw = (argStatePoint: IPointOnImg): void => {\n    const canvas: HTMLCanvasElement = canvasPreview.current;\n    const ctx: CanvasRenderingContext2D = canvas.getContext('2d')!;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    if (argStatePoint?.pointPlace?.x && argStatePoint?.pointPlace?.y) {\n      ctx.fillStyle = 'red';\n      ctx.beginPath();\n\n      ctx.arc(argStatePoint.pointPlace.x, argStatePoint.pointPlace.y, argStatePoint.pointWidth, 0, 2 * Math.PI, true);\n\n      ctx.fill();\n    }\n  };\n\n  React.useEffect(() => {\n    resize();\n  }, [resize, currentImg]);\n\n  React.useEffect(() => {\n    setPxStatePoint(calcPxStatePoint(statePoint, canvasPreview.current));\n  }, [statePoint]);\n\n  React.useEffect(() => {\n    if (pxStatePoint) {\n      draw(pxStatePoint);\n    }\n  }, [pxStatePoint]);\n\n  React.useEffect(() => {\n    setActiveChangeSettings(mouseIntoBlock);\n  }, [mouseIntoBlock]);\n\n  React.useLayoutEffect(() => {\n    window.addEventListener('resize', resize);\n    return () => {\n      window.removeEventListener('resize', resize);\n    };\n  }, [statePoint, resize]);\n\n  const onDown = (e: React.MouseEvent<HTMLCanvasElement>): void | false => {\n    if (e.button === 2) {\n      return false;\n    }\n    const [x, y] = getOffset(e);\n    const newState = { x, y };\n    setActiveChange(true);\n    setPxStatePoint({\n      ...pxStatePoint,\n      pointWidth: calcWidthPoint(pxStatePoint.pointPlace),\n      pointPlace: newState,\n    });\n  };\n\n  const onUp = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (activeChange) {\n      const [x, y] = getOffset(e);\n\n      setStatePoint({\n        pointWidth: calcPercentFromPx(ImgPreview.current.width, calcWidthPoint(pxStatePoint.pointPlace, { x, y })),\n        pointPlace: {\n          x: calcPercentFromPx(ImgPreview.current.width, pxStatePoint.pointPlace.x),\n          y: calcPercentFromPx(ImgPreview.current.height, pxStatePoint.pointPlace.y),\n        },\n      });\n\n      setActiveChange(false);\n    }\n  };\n\n  const onMove = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    const [x, y] = getOffset(e);\n    if (activeChange) {\n      const currentState = {\n        ...pxStatePoint,\n        pointWidth: calcWidthPoint(pxStatePoint.pointPlace, { x, y }),\n      };\n      draw(currentState);\n    }\n    setMouseIntoBlock(true);\n  };\n\n  const onLeave = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    setMouseIntoBlock(false);\n    setActiveChange(false);\n  };\n\n  const cancelPoint = (e: React.MouseEvent): void => {\n    if (e) {\n      e.preventDefault();\n    }\n    setStatePoint();\n  };\n\n  /*   const handleTouchStart = (): void => {\n    timer = setTimeout(cancelPoint, touchduration);\n  };\n\n  const handleTouchEnd = (): void => {\n    if (timer) clearTimeout(timer);\n  }; */\n\n  return (\n    <div className={styles.blockImgPreview}>\n      <img ref={ImgPreview} alt=\"main\" src={currentImg.preview} />\n      <canvas\n        ref={canvasPreview}\n        /*       onClick={ setPoint } */\n        onContextMenu={cancelPoint}\n        onMouseDown={onDown}\n        onMouseLeave={onLeave}\n        onMouseMove={onMove}\n        onMouseUp={onUp}\n      />\n    </div>\n  );\n};\n\nexport default BlockImgPreview;\n","/app/src/components/Dropzone/index.tsx",[],"/app/src/components/Buttons/controlStepperButtons/index.tsx",[],"/app/src/services/imageService.ts",["154","155","156","157","158","159"],"import {\n  ICropNewData,\n  IPointPlace,\n  ICropFormData,\n  IPointOnImg,\n  IImgSettingsNaturalSize,\n  ISettingImg,\n  IInfoImg,\n  ISettingsImage,\n} from '../interfaces/items';\n\nexport const getImgFromPreviewFile = (preview: string): Promise<HTMLImageElement> =>\n  new Promise((resolve) => {\n    const img: HTMLImageElement = new Image();\n    img.onload = () => {\n      resolve(img);\n    };\n    img.src = preview;\n  });\n\nexport const calcProportion = (firstArg: number, necessarySize: number, secondArg: number): number => {\n  const propotion: number = Math.round(firstArg * (necessarySize / secondArg));\n  return propotion;\n};\n\nexport const getTypeByPropotion = (proportionWidth: number, proportionHeight: number, types: string[]): string => {\n  if (proportionWidth / proportionHeight > 1) {\n    return types[0];\n  }\n  return types[1];\n};\n\nexport const calcPxFromPercent = (naturalSize: number, val: number): number => {\n  const pixelVal = Math.round(naturalSize * (val / 100));\n  return pixelVal;\n};\n\nexport const calcPercentFromPx = (naturalSize: number, val: number): number => {\n  const percentVal = Math.round((val / naturalSize) * 100);\n  return percentVal;\n};\n\nexport const transformPxAndPercent = (\n  image: HTMLImageElement,\n  objCrop: ICropNewData,\n  fnTransform: (naturalSize: number, val: number) => number\n): ICropNewData => {\n  let height = null;\n  let width = null;\n  const transformedValues: { width?: number; height?: number } = {};\n  if (objCrop.height) {\n    height = fnTransform(image.naturalHeight, objCrop.height);\n    transformedValues.height = height;\n  }\n  if (objCrop.width) {\n    width = fnTransform(image.naturalWidth, objCrop.width);\n    transformedValues.width = width;\n  }\n  return transformedValues;\n};\n\nexport const calcAspect = ({ width, height }: ICropFormData): number => {\n  if (height <= 0 || width <= 0) {\n    return 1;\n  }\n  const aspect = width / height;\n  return aspect;\n};\n\nexport const generateImagesBySettings = async (img: HTMLImageElement, settings: ISettingImg): Promise<Blob> => {\n  const canvas = document.createElement('canvas');\n  canvas.width = settings.width;\n  canvas.height = settings.height;\n\n  const context = canvas.getContext('2d');\n\n  context!.drawImage(\n    img,\n    settings.x,\n    settings.y,\n    settings.width,\n    settings.height,\n    0,\n    0,\n    settings.width,\n    settings.height\n  );\n\n  return new Promise((resolve, reject) => {\n    canvas.toBlob(\n      (blob) => {\n        if (blob) {\n          resolve(blob);\n        }\n        reject();\n      },\n      'image/jpeg',\n      1\n    );\n  });\n};\n\nexport const getPositionByPoint = (\n  data: ICropFormData,\n  point: IPointOnImg,\n  imgSettings: IImgSettingsNaturalSize\n): ISettingImg => {\n  const pointFromPx = {\n    pointPlace: {\n      x: calcPxFromPercent(imgSettings.naturalWidth, point.pointPlace.x),\n      y: calcPxFromPercent(imgSettings.naturalHeight, point.pointPlace.y),\n    },\n    pointWidth: calcPxFromPercent(imgSettings.naturalHeight, point.pointWidth),\n  };\n\n  const radius = pointFromPx.pointWidth;\n\n  const minSide = radius * 2;\n\n  const newWidth = Math.max(minSide, data.width);\n  const newHeight = Math.max(minSide, data.height);\n\n  const newLeft = pointFromPx.pointPlace.x - newWidth / 2;\n  const newTop = pointFromPx.pointPlace.y - newHeight / 2;\n\n  return {\n    ...data,\n    width: newWidth,\n    height: newHeight,\n    x: newLeft >= 0 ? newLeft : 0,\n    y: newTop >= 0 ? newTop : 0,\n  };\n};\n\nexport const getPositionByPointDouble = (\n  data: ICropFormData,\n  point: IPointOnImg,\n  imgSettings: IImgSettingsNaturalSize\n): ISettingImg => {\n  const pointFromPx = {\n    x: calcPxFromPercent(imgSettings.naturalWidth, point.pointPlace.x),\n    y: calcPxFromPercent(imgSettings.naturalHeight, point.pointPlace.y),\n  };\n  const dataFromPx = {\n    width: calcPxFromPercent(imgSettings.naturalWidth, data.width),\n    height: calcPxFromPercent(imgSettings.naturalHeight, data.height),\n  };\n  const halfWidth = dataFromPx.width / 2;\n  const halfHeight = dataFromPx.height / 2;\n\n  let newPoints: any = {\n    newLeft: pointFromPx.x - halfWidth,\n    newTop: pointFromPx.y - halfHeight,\n    newRight: pointFromPx.x + halfWidth,\n    newBot: pointFromPx.y + halfHeight,\n  };\n\n  if (imgSettings.naturalWidth < newPoints.newRight) {\n    const needPxW = newPoints.newRight - imgSettings.naturalWidth;\n    const newRight = newPoints.newRight - needPxW;\n    const newLeft = newPoints.newLeft - needPxW;\n    newPoints = {\n      ...newPoints,\n      newRight,\n      newLeft,\n    };\n  }\n\n  if (imgSettings.naturalHeight < newPoints.newBot) {\n    const needPxH = newPoints.newBot - imgSettings.naturalHeight;\n    const newBot = newPoints.newBot - needPxH;\n    const newTop = newPoints.newTop - needPxH;\n    newPoints = {\n      ...newPoints,\n      newBot,\n      newTop,\n    };\n  }\n\n  return {\n    ...dataFromPx,\n    x: newPoints.newLeft >= 0 ? newPoints.newLeft : 0,\n    y: newPoints.newTop >= 0 ? newPoints.newTop : 0,\n  };\n};\n\nexport const generateKitImages = async (\n  imgElement: HTMLImageElement,\n  kitSettings: ISettingsImage\n): Promise<IInfoImg[]> => {\n  const kitImages: IInfoImg[] = [];\n  for (let idxEl = 0; idxEl < kitSettings.items.length; idxEl++) {\n    const settings = kitSettings.items[idxEl];\n    const blobImg: Blob = await generateImagesBySettings(imgElement, settings);\n    const fileImg: IInfoImg = {\n      infoByFile: new File([blobImg], `${idxEl}.jpg`),\n    };\n    fileImg.preview = URL.createObjectURL(fileImg.infoByFile);\n\n    kitImages.push(fileImg);\n  }\n  return kitImages;\n};\n\nexport const generateNewSettingsForKitImages = (\n  imgElement: HTMLImageElement,\n  settings: ISettingImg[],\n  newPoint: IPointOnImg\n): ISettingsImage => {\n  const newKitSettings: any[] = [];\n  for (let idxEl = 0; idxEl < settings.length; idxEl++) {\n    let currentSetting = settings[idxEl];\n    currentSetting = getPositionByPointDouble(currentSetting, newPoint, imgElement);\n\n    newKitSettings.push(currentSetting);\n  }\n  return {\n    items: newKitSettings,\n    point: newPoint,\n  };\n};\n\nexport const calcMinMaxValue = (first: number, second: number): number[] => {\n  if (first > second) {\n    return [second, first];\n  }\n  return [first, second];\n};\n\nexport const calcWidthPoint = (firstObj: IPointPlace, secondObj?: IPointPlace): number => {\n  const defaultWidth = 3;\n\n  if (!secondObj) {\n    return defaultWidth;\n  }\n\n  const [minX, maxX] = calcMinMaxValue(firstObj.x, secondObj.x);\n  const [minY, maxY] = calcMinMaxValue(firstObj.y, secondObj.y);\n\n  const newWidth = {\n    x: Math.round(maxX - minX),\n    y: Math.round(maxY - minY),\n  };\n\n  const [, maxNewWidth] = calcMinMaxValue(newWidth.x, newWidth.y);\n\n  return Math.max(maxNewWidth, defaultWidth);\n};\n\nexport const calcWidthPointOnCanvas = (pointWidth: number, canvas: HTMLCanvasElement, func: any): number => {\n  const maxVal = Math.max(canvas.width, canvas.height);\n  const widthPercent = func(maxVal, pointWidth);\n  return widthPercent;\n};\n\nexport const calcPlacePoint = (start: IPointPlace, end: IPointPlace): IPointPlace => {\n  const halfWidth = {\n    x: Math.round((end.x! - start.x!) / 2),\n    y: Math.round((end.y! - start.y!) / 2),\n  };\n\n  const newPointPlace = {\n    x: halfWidth.x + start.x!,\n    y: halfWidth.y + start.y!,\n  };\n\n  return newPointPlace;\n};\n\nexport const getPxWidthPoint = (pointWidth: number, canvas: HTMLCanvasElement) => {\n  const widthPointPx = calcWidthPointOnCanvas(pointWidth, canvas, calcPxFromPercent);\n  const defaultWidthPoint = 3;\n\n  if (widthPointPx === 0) {\n    return defaultWidthPoint;\n  }\n  return widthPointPx;\n};\n\nexport const calcPxStatePoint = (argStatePoint: IPointOnImg, canvas: HTMLCanvasElement): IPointOnImg => {\n  if (argStatePoint?.pointPlace?.x && argStatePoint?.pointPlace?.y && argStatePoint.pointWidth && canvas) {\n    return {\n      pointPlace: {\n        x: calcPxFromPercent(canvas.width, argStatePoint.pointPlace.x),\n        y: calcPxFromPercent(canvas.height, argStatePoint.pointPlace.y),\n      },\n      pointWidth: getPxWidthPoint(argStatePoint.pointWidth, canvas),\n    };\n  }\n\n  return argStatePoint;\n};\n\nexport const getWidthPoint = (firstObj: IPointPlace, secondObj?: IPointPlace) => {\n  const pointWidth = calcWidthPoint(firstObj, secondObj);\n  // const widthPointPercent = calcWidthPointOnCanvas(pointWidth, canvasPreview.current, calcPercentFromPx);\n\n  return pointWidth;\n};\n\nexport const transformSettingsInPercent = ({ items, point }: ISettingsImage, imgElement: HTMLImageElement) => {\n  const changedItems = items.map((el: ISettingImg) => {\n    const changedEl = {\n      x: calcPercentFromPx(imgElement.naturalWidth, el.x),\n      y: calcPercentFromPx(imgElement.naturalHeight, el.y),\n      width: calcPercentFromPx(imgElement.naturalWidth, el.width),\n      height: calcPercentFromPx(imgElement.naturalHeight, el.height),\n    };\n    return changedEl;\n  });\n\n  return {\n    point,\n    items: changedItems,\n  };\n};\n\nexport const transformSettingsInPx = ({ items, point }: ISettingsImage, imgElement: HTMLImageElement) => {\n  const changedItems = items.map((el: ISettingImg) => {\n    const changedEl = {\n      x: calcPxFromPercent(imgElement.naturalWidth, el.x),\n      y: calcPxFromPercent(imgElement.naturalHeight, el.y),\n      width: calcPxFromPercent(imgElement.naturalWidth, el.width),\n      height: calcPxFromPercent(imgElement.naturalHeight, el.height),\n    };\n    return changedEl;\n  });\n\n  return {\n    point,\n    items: changedItems,\n  };\n};\n","/app/src/services/fileService.ts",[],"/app/src/components/Crop/CropForm/index.tsx",["160"],"import React, { ChangeEvent, useCallback } from 'react';\nimport { Button, Select, MenuItem, TextField } from '@material-ui/core';\nimport { ICropFormData, ICropNewData } from 'interfaces/items';\nimport styles from '../Crop.module.css';\n\nconst typeCropWords = ['px', '%', 'aspect'];\n\nconst CropForm: React.FC<{\n  onSetCrop: (data: ICropNewData) => void;\n  onSetAspect: (data: ICropNewData) => void;\n  getCropImage: () => void;\n  cropPx: ICropFormData;\n  cropPercent: ICropFormData;\n  aspect: ICropFormData;\n  typeCrop: string;\n  setTypeCrop: (data: string) => void;\n}> = ({ onSetCrop, onSetAspect, cropPx, cropPercent, aspect, typeCrop, getCropImage, setTypeCrop }) => {\n  const onChangeTypeCrop = (event: React.ChangeEvent<any>) => {\n    const newTypeCrop = event.target.value;\n    setTypeCrop(newTypeCrop);\n  };\n\n  const onSetValue = ({ target }: ChangeEvent<HTMLTextAreaElement>): void => {\n    const { name, value } = target;\n    const newValue = { [name]: parseInt(value, 10) };\n    if (typeCrop === 'aspect') {\n      onSetAspect(newValue);\n      return;\n    }\n\n    onSetCrop(newValue);\n  };\n\n  const generateInputs = useCallback(() => {\n    let crop: ICropFormData = cropPx;\n    if (typeCrop === '%') {\n      crop = cropPercent;\n    } else if (typeCrop === 'aspect') {\n      crop = aspect;\n    }\n\n    return (\n      <>\n        <TextField label=\"Width\" name=\"width\" type=\"number\" value={crop.width} onChange={onSetValue} />\n        <TextField label=\"Height\" name=\"height\" type=\"number\" value={crop.height} onChange={onSetValue} />\n      </>\n    );\n  }, [typeCrop, cropPx, cropPercent, aspect]);\n\n  return (\n    <form autoComplete=\"off\" className={styles.cropForm} noValidate>\n      {generateInputs()}\n      <Select value={typeCrop} onChange={onChangeTypeCrop}>\n        {typeCropWords.map((word: string) => (\n          <MenuItem key={`${word}`} value={word}>\n            {word}\n          </MenuItem>\n        ))}\n      </Select>\n      <Button color=\"primary\" onClick={getCropImage}>\n        Save\n      </Button>\n    </form>\n  );\n};\n\nexport default CropForm;\n","/app/src/components/Buttons/CloseButton/index.tsx",[],"/app/src/components/Dropzone/DropzonePreview/index.tsx",[],"/app/src/components/Thumb/index.tsx",[],{"ruleId":"161","severity":1,"message":"162","line":2,"column":23,"nodeType":"163","messageId":"164","endLine":2,"endColumn":30},{"ruleId":"165","severity":1,"message":"162","line":2,"column":23,"nodeType":"163","messageId":"164","endLine":2,"endColumn":30},{"ruleId":"161","severity":1,"message":"166","line":2,"column":32,"nodeType":"163","messageId":"164","endLine":2,"endColumn":38},{"ruleId":"165","severity":1,"message":"166","line":2,"column":32,"nodeType":"163","messageId":"164","endLine":2,"endColumn":38},{"ruleId":"161","severity":1,"message":"162","line":1,"column":56,"nodeType":"163","messageId":"164","endLine":1,"endColumn":63},{"ruleId":"165","severity":1,"message":"162","line":1,"column":56,"nodeType":"163","messageId":"164","endLine":1,"endColumn":63},{"ruleId":"167","severity":1,"message":"168","line":25,"column":23,"nodeType":"169","messageId":"170","endLine":25,"endColumn":91},{"ruleId":"171","severity":1,"message":"172","line":9,"column":59,"nodeType":"163","messageId":"173","endLine":9,"endColumn":68},{"ruleId":"161","severity":1,"message":"174","line":1,"column":10,"nodeType":"163","messageId":"164","endLine":1,"endColumn":21},{"ruleId":"165","severity":1,"message":"174","line":1,"column":10,"nodeType":"163","messageId":"164","endLine":1,"endColumn":21},{"ruleId":"175","severity":1,"message":"176","line":4,"column":1,"nodeType":"177","endLine":4,"endColumn":37},{"ruleId":"161","severity":1,"message":"178","line":25,"column":10,"nodeType":"163","messageId":"164","endLine":25,"endColumn":21},{"ruleId":"165","severity":1,"message":"178","line":25,"column":10,"nodeType":"163","messageId":"164","endLine":25,"endColumn":21},{"ruleId":"161","severity":1,"message":"179","line":25,"column":23,"nodeType":"163","messageId":"164","endLine":25,"endColumn":37},{"ruleId":"165","severity":1,"message":"179","line":25,"column":23,"nodeType":"163","messageId":"164","endLine":25,"endColumn":37},{"ruleId":"161","severity":1,"message":"180","line":29,"column":9,"nodeType":"163","messageId":"164","endLine":29,"endColumn":23},{"ruleId":"165","severity":1,"message":"180","line":29,"column":9,"nodeType":"163","messageId":"164","endLine":29,"endColumn":23},{"ruleId":"161","severity":1,"message":"181","line":125,"column":20,"nodeType":"163","messageId":"164","endLine":125,"endColumn":58},{"ruleId":"165","severity":1,"message":"181","line":125,"column":20,"nodeType":"163","messageId":"164","endLine":125,"endColumn":58},{"ruleId":"167","severity":1,"message":"168","line":194,"column":27,"nodeType":"169","messageId":"170","endLine":194,"endColumn":79},{"ruleId":"171","severity":1,"message":"182","line":250,"column":87,"nodeType":"163","messageId":"173","endLine":250,"endColumn":96},{"ruleId":"171","severity":1,"message":"183","line":270,"column":32,"nodeType":"184","messageId":"185","endLine":270,"endColumn":82},{"ruleId":"171","severity":1,"message":"183","line":294,"column":30,"nodeType":"184","messageId":"185","endLine":294,"endColumn":81},{"ruleId":"171","severity":1,"message":"183","line":301,"column":43,"nodeType":"184","messageId":"185","endLine":301,"endColumn":110},{"ruleId":"171","severity":1,"message":"183","line":318,"column":38,"nodeType":"184","messageId":"185","endLine":318,"endColumn":105},{"ruleId":"186","severity":1,"message":"187","line":48,"column":6,"nodeType":"188","endLine":48,"endColumn":45,"suggestions":"189"},"no-unused-vars","'forward' is defined but never used.","Identifier","unusedVar","@typescript-eslint/no-unused-vars","'sample' is defined but never used.","no-await-in-loop","Unexpected `await` inside a loop.","AwaitExpression","unexpectedAwait","@typescript-eslint/explicit-module-boundary-types","Argument 'data' should be typed with a non-any type.","anyTypedArg","'IPointPlace' is defined but never used.","import/no-extraneous-dependencies","'cropperjs' should be listed in the project's dependencies. Run 'npm i -S cropperjs' to add it","ImportDeclaration","'savedPxData' is assigned a value but never used.","'setSavedPxData' is assigned a value but never used.","'stateCropPoint' is assigned a value but never used.","'e' is defined but never used.","Argument 'func' should be typed with a non-any type.","Missing return type on function.","ArrowFunctionExpression","missingReturnType","react-hooks/exhaustive-deps","React Hook useCallback has a missing dependency: 'onSetValue'. Either include it or remove the dependency array.","ArrayExpression",["190"],{"desc":"191","fix":"192"},"Update the dependencies array to be: [cropPx, typeCrop, onSetValue, cropPercent, aspect]",{"range":"193","text":"194"},[1556,1595],"[cropPx, typeCrop, onSetValue, cropPercent, aspect]"]